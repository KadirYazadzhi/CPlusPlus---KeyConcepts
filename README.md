# Основни концепции в C++

Този документ обяснява основните концепции в C++, като предоставя кратки обяснения и примери за всяка тема. Целта е да се улесни разбирането и да се предостави полезен справочник.

---

## 1. Референции (References)
Референцията е **алтернатива на указателя**. Тя създава псевдоним (alias) за вече съществуваща променлива, което означава, че референцията сочи директно към стойността на променливата.

### Плюсове:
- Лесни за използване.
- Предотвратяват нулиране на указатели (null pointers).

### Минуси:
- Не могат да бъдат пренасочвани след инициализация.

```cpp
int a = 5;
int& ref = a; // референция към 'a'
ref = 10;     // променя 'a' на 10
```

## 2. Указатели (Pointers)
Указателите са **променливи, които съхраняват адреса на друга променлива**. Те са полезни при динамично разпределяне на памет и директна работа с паметта.

### Плюсове:
- Предоставят директен достъп до паметта.
- Могат да бъдат пренасочвани.

### Минуси:
- Могат да водят до грешки като **dangling pointers** или **memory leaks**.

```cpp
int a = 5;
int* ptr = &a; // указател към 'a'
*ptr = 10;     // променя 'a' на 10
```


## 3. Масиви (Arrays)
Масивът е **последователност от елементи с фиксиран размер**. Всички елементи в масива трябва да са от един и същи тип.

### Плюсове:
- Прост и ефективен за съхранение на множество стойности.

### Минуси:
- Размерът на масива трябва да бъде известен предварително.
- Липсва гъвкавост при добавяне на нови елементи.

```cpp
int arr[5] = {1, 2, 3, 4, 5};
arr[0] = 10; // Променя първия елемент
```


## 4. Двумерни масиви (2D Arrays)
Двумерните масиви **са масиви от масиви** и могат да се използват за съхраняване на матрици.

### Плюсове:
- Удобни за работа с матрици и таблични данни.

### Минуси:
- Както и при едномерните масиви, размерът им трябва да е известен предварително.

```cpp
int matrix[3][3] = {
  {1, 2, 3},
  {4, 5, 6},
  {7, 8, 9}
};
```


## 5. Функции (Functions)
Функциите са **блокове от код**, които могат да се извикват многократно. Те могат да приемат аргументи и да връщат резултати.

### Плюсове:
- Разделят кода на по-малки, управляеми части.
- Подобряват четимостта на кода, ако са използвани правилно.

### Минуси:
- Могат да бъдат по-неефективни от инлайн код поради извикване на функцията.

```cpp
int add(int a, int b) {
  return a + b;
}

int result = add(3, 4); // result = 7
```


## 6. Стекове (Stacks)
Стекът е **LIFO (Last In, First Out)** структура от данни, която позволява добавяне и премахване на елементи само от върха.

### Плюсове:
- Полезен за задачи като обратен обход или рекурсия.

### Минуси:
- Достъп до елементи само от върха.

```cpp
#include <stack>

std::stack<int> s;
s.push(1);
s.push(2);
s.pop(); // Премахва последния елемент (2)
```

## 7. Опашки (Queues)
Опашката е **FIFO (First In, First Out)** структура, която позволява добавяне на елементи от единия край и премахване от другия.

### Плюсове:
- Полезна за моделиране на поредни процеси, като задачи или заявки.

### Минуси:
- Ограничен достъп – можеш да премахваш само от началото и да добавяш само в края.

```cpp
#include <queue>

std::queue<int> q;
q.push(1);
q.push(2);
q.pop(); // Премахва първия елемент (1)
```

## 8. Сетове (Sets)
Сетът е **контейнер, който съхранява уникални елементи**, като не допуска дублиране.

### Плюсове:
- Гарантира, че няма дубликати.
- Бързо търсене на елементи.

### Минуси:
- Бавен при добавяне на много елементи, тъй като трябва да проверява уникалността.

```cpp
#include <set>

std::set<int> mySet;
mySet.insert(1);
mySet.insert(2);
mySet.insert(1); // 1 вече съществува, така че няма да бъде добавен отново
```

## 9. Вектори (Vectors)
Векторите са **динамични масиви**. Те се разширяват автоматично при добавяне на нови елементи.

### Плюсове:
- Гъвкав размер – не е нужно да знаеш предварително колко елементи ще имаш.
- Бърз достъп по индекс.

### Минуси:
- При добавяне на нови елементи в средата или началото може да има нужда от преместване на елементите, което е по-бавно.

```cpp
#include <vector>

std::vector<int> v = {1, 2, 3};
v.push_back(4); // Добавя елемент в края
```


## 10. Опашки с приоритет (Priority Queues)
Опашката с приоритет подрежда елементите **според техния приоритет** – елементите с най-висок приоритет се премахват първи.

### Плюсове:
- Полезни за задачи като планиране, където някои задачи имат приоритет над други.

### Минуси:
- По-бавни от обикновените опашки поради подреждането.

```cpp
#include <queue>

std::priority_queue<int> pq;
pq.push(10);
pq.push(20);
pq.pop(); // Премахва най-големия елемент (20)
```


## 11. Рекурсия (Recursion)
Рекурсията е метод, при който функцията извиква сама себе си. Полезна е за задачи, които могат да бъдат разделени на по-малки подобни подзадачи.

### Плюсове:
- Лесен начин за изразяване на проблеми като обхождане на дървета или търсене.

### Минуси:
- Може да доведе до изчерпване на стека (stack overflow), ако не се управлява правилно.

```cpp
int factorial(int n) {
  if (n == 0) return 1;
  return n * factorial(n - 1);
}

int result = factorial(5); // result = 120
```
